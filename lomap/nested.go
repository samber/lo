// Code generated by generate_nested.go; DO NOT EDIT.
package lomap

//go:generate go run internal/generate/nested/generate_nested.go

func Nested2[M1 ~map[K1]M2, M2 ~map[K2]T, K1, K2 comparable, T any](
	m1 M1, k1 K1, k2 K2,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	v, ok = m2[k2]
	return
}

func Nested3[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]T, K1, K2, K3 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	v, ok = m3[k3]
	return
}

func Nested4[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]T, K1, K2, K3, K4 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	v, ok = m4[k4]
	return
}

func Nested5[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]M5, M5 ~map[K5]T, K1, K2, K3, K4, K5 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4, k5 K5,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	m5, ok := m4[k4]
	if !ok {
		return
	}

	v, ok = m5[k5]
	return
}

func Nested6[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]M5, M5 ~map[K5]M6, M6 ~map[K6]T, K1, K2, K3, K4, K5, K6 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4, k5 K5, k6 K6,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	m5, ok := m4[k4]
	if !ok {
		return
	}

	m6, ok := m5[k5]
	if !ok {
		return
	}

	v, ok = m6[k6]
	return
}

func Nested7[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]M5, M5 ~map[K5]M6, M6 ~map[K6]M7, M7 ~map[K7]T, K1, K2, K3, K4, K5, K6, K7 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4, k5 K5, k6 K6, k7 K7,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	m5, ok := m4[k4]
	if !ok {
		return
	}

	m6, ok := m5[k5]
	if !ok {
		return
	}

	m7, ok := m6[k6]
	if !ok {
		return
	}

	v, ok = m7[k7]
	return
}

func Nested8[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]M5, M5 ~map[K5]M6, M6 ~map[K6]M7, M7 ~map[K7]M8, M8 ~map[K8]T, K1, K2, K3, K4, K5, K6, K7, K8 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4, k5 K5, k6 K6, k7 K7, k8 K8,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	m5, ok := m4[k4]
	if !ok {
		return
	}

	m6, ok := m5[k5]
	if !ok {
		return
	}

	m7, ok := m6[k6]
	if !ok {
		return
	}

	m8, ok := m7[k7]
	if !ok {
		return
	}

	v, ok = m8[k8]
	return
}

func Nested9[M1 ~map[K1]M2, M2 ~map[K2]M3, M3 ~map[K3]M4, M4 ~map[K4]M5, M5 ~map[K5]M6, M6 ~map[K6]M7, M7 ~map[K7]M8, M8 ~map[K8]M9, M9 ~map[K9]T, K1, K2, K3, K4, K5, K6, K7, K8, K9 comparable, T any](
	m1 M1, k1 K1, k2 K2, k3 K3, k4 K4, k5 K5, k6 K6, k7 K7, k8 K8, k9 K9,
) (v T, ok bool) {

	m2, ok := m1[k1]
	if !ok {
		return
	}

	m3, ok := m2[k2]
	if !ok {
		return
	}

	m4, ok := m3[k3]
	if !ok {
		return
	}

	m5, ok := m4[k4]
	if !ok {
		return
	}

	m6, ok := m5[k5]
	if !ok {
		return
	}

	m7, ok := m6[k6]
	if !ok {
		return
	}

	m8, ok := m7[k7]
	if !ok {
		return
	}

	m9, ok := m8[k8]
	if !ok {
		return
	}

	v, ok = m9[k9]
	return
}
