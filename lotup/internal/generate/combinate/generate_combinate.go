//go:build generate_monad

package main

import (
	_ "embed"

	"bytes"
	"fmt"
	"io/fs"
	"log/slog"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

const (
	monadGeneratorPath = "internal/generate/combinate/generate_combinate.go"
	filename           = "combinate.go"

	ownerWritePermission = 0o644

	argumentsLimit = 9
)

var (
	//go:embed templates/zip.gotmpl
	zipRaw string

	//go:embed templates/unzip.gotmpl
	unzipRaw string

	//go:embed templates/product.gotmpl
	productRaw string
)

type Variant struct {
	N int
}

func main() {
	funcMap := template.FuncMap{
		"add": func(x, y int) int { return x + y },
		"sub": func(x, y int) int { return x - y },
	}
	zipTmpl := template.Must(template.New("zip").Funcs(funcMap).Parse(zipRaw))
	unzipTmpl := template.Must(template.New("unzip").Funcs(funcMap).Parse(unzipRaw))
	productTmpl := template.Must(template.New("product").Funcs(funcMap).Parse(productRaw))

	pkg := detectPackageName()

	var buf bytes.Buffer

	buf.WriteString("// Code generated by generate_combinate.go; DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", pkg))
	buf.WriteString(fmt.Sprintf("//go:generate go run %s\n", monadGeneratorPath))

	for n := 2; n <= argumentsLimit; n++ {
		err := zipTmpl.Execute(&buf, Variant{N: n})
		if err != nil {
			panic(err)
		}

		err = unzipTmpl.Execute(&buf, Variant{N: n})
		if err != nil {
			panic(err)
		}

		err = productTmpl.Execute(&buf, Variant{N: n})
		if err != nil {
			panic(err)
		}
	}

	err := os.WriteFile(filename, buf.Bytes(), fs.FileMode(ownerWritePermission))
	if err != nil {
		panic(err)
	}

	slog.Info("done")
}

func detectPackageName() string {
	out, err := exec.Command("go", "list", "-f", "{{.Name}}").Output()
	if err != nil {
		panic(err)
	}

	return strings.TrimSpace(string(out))
}
