# Lo - A Go library for functional programming

Lo is a comprehensive, production-ready Lodash-style Go library built on Go 1.18+ generics that provides hundreds of utility functions for working with slices, maps, strings, channels, functions, and more. It aims to make Go code more expressive, readable, and productive by offering a rich collection of functional programming helpers inspired by libraries like Lodash in JavaScript.

## Origins and Purpose

Born from the need to fill gaps in Go's standard library after the introduction of generics in Go 1.18, Lo addresses common pain points that Go developers face daily. While Go's standard library gained some generic helpers in `slices` and `maps` packages, Lo goes far beyond with 300+ carefully crafted utilities that make functional programming patterns natural and idiomatic in Go.

The library emerged from real-world production needs and has been battle-tested in numerous high-traffic applications, microservices, and enterprise systems. It's not just a collection of utility functions, but a thoughtful toolkit that enables developers to write more declarative, maintainable, and bug-free code.

## Key Features

- **Generic-based**: Fully leverages Go 1.18+ generics for compile-time type safety
- **Zero dependencies**: No external dependencies outside the Go standard library
- **Comprehensive**: 300+ helpers covering slices, maps, strings, channels, functions, and more
- **Functional programming**: Brings functional programming paradigms to Go naturally
- **Production-ready**: Battle-tested in high-traffic applications worldwide
- **Well-tested**: 95%+ test coverage with comprehensive examples
- **SemVer compliant**: Follows strict semantic versioning (v1.x.x stable)
- **Performance-focused**: Minimal runtime overhead with optimized implementations
- **Memory efficient**: Many helpers avoid allocations and use zero-copy patterns
- **Composable**: Designed to work together in method chains and complex pipelines

## Sub-packages

The main package is complemented by several specialized sub-packages:

- **lo**: Core package with 300+ helpers for everyday operations
- **lo/parallel**: Parallel processing helpers for concurrent operations
- **lo/mutable**: In-place mutation helpers for memory-efficient operations
- **lo/it**: Iterator helpers for lazy evaluation and streaming

## Design Philosophy

Lo is built on a foundation of pragmatic engineering principles that balance power, safety, and performance:

1. **Type Safety First**: All helpers leverage Go's generics for compile-time type checking, eliminating runtime type assertions and reducing bugs
2. **Go Idiomatic**: While inspired by functional programming, helpers feel natural in Go code and follow established conventions
3. **Performance Conscious**: Every helper is benchmarked and optimized for minimal overhead, with many using zero-copy patterns
4. **Explicit Clarity**: Helper names clearly communicate their purpose and behavior
5. **Composable by Design**: Functions work together seamlessly, enabling elegant data transformation pipelines
6. **Memory Efficient**: Careful attention to allocation patterns, with many helpers avoiding unnecessary heap allocations
7. **Error Handling Respect**: Helpers don't hide errors; they integrate naturally with Go's error handling patterns
8. **Practical Over Pure**: Prioritizes solving real-world problems over theoretical purity

## Core Package Helpers

### Condition
- Ternary: Ternary operator
- TernaryF: Ternary operator with function execution
- If: Conditional statement that returns a value
- IfF: Conditional statement with function execution
- ElseIf: Else-if conditional statement
- ElseIfF: Else-if conditional statement with function execution
- Else: Else conditional statement
- ElseF: Else conditional statement with function execution
- Switch: Switch statement that returns a value
- Case: Case statement
- CaseF: Case statement with function execution
- Default: Default case statement
- DefaultF: Default case statement with function execution

### Concurrency
- Synchronize: Synchronize goroutines
- Async: Execute function asynchronously
- Async0-Async6: Execute functions with 0-6 return values asynchronously
- WaitFor: Wait for condition to be true
- WaitForWithContext: Wait for condition with context

### Error Handling
- Validate: Validate condition and return error
- Must: Must helper with panic on error
- Must0-Must6: Must helpers with 0-6 return values
- Try: Try helper with panic on error
- Try0-Try6: Try helpers with 0-6 return values
- TryOr: Try with fallback value
- TryOr1-TryOr6: Try with fallback values for 1-6 return values
- TryWithErrorValue: Try with error value
- TryCatch: Try-catch block
- TryCatchWithErrorValue: Try-catch with error value
- ErrorsAs: Convert errors
- Assert: Assert condition
- Assertf: Assert condition with formatting

### Find
- IndexOf: Find index of element
- LastIndexOf: Find last index of element
- HasPrefix: Check if collection has prefix
- HasSuffix: Check if collection has suffix
- Find: Find element in collection
- FindIndexOf: Find element and its index
- FindLastIndexOf: Find last occurrence and its index
- FindOrElse: Find element or return fallback
- FindKey: Find key in map by value
- FindKeyBy: Find key by predicate
- FindUniques: Find unique elements
- FindUniquesBy: Find unique elements by predicate
- FindDuplicates: Find duplicate elements
- FindDuplicatesBy: Find duplicates by predicate
- Min: Find minimum value
- MinIndex: Find minimum index
- MinBy: Find minimum by predicate
- MinIndexBy: Find minimum index by predicate
- Earliest: Find earliest time
- EarliestBy: Find earliest by predicate
- Max: Find maximum value
- MaxIndex: Find maximum index
- MaxBy: Find maximum by predicate
- MaxIndexBy: Find maximum index by predicate
- Latest: Find latest time
- LatestBy: Find latest by predicate
- First: Get first element
- FirstOrEmpty: Get first element or empty value
- FirstOr: Get first element or fallback
- Last: Get last element
- LastOrEmpty: Get last element or empty value
- LastOr: Get last element or fallback
- Nth: Get nth element
- NthOr: Get nth element or fallback
- NthOrEmpty: Get nth element or empty value
- Sample: Sample random element
- SampleBy: Sample by predicate
- Samples: Sample multiple elements
- SamplesBy: Sample multiple by predicate

### Function
- Partial: Create partial function
- Partial1-Partial5: Create partial functions with 1-5 arguments

### Intersect
- Contains: Check if collection contains element
- ContainsBy: Check if collection contains by predicate
- Every: Check if collection contains all elements
- EveryBy: Check if collection contains all by predicate
- Some: Check if collection contains some elements
- SomeBy: Check if collection contains some by predicate
- None: Check if collection contains none
- NoneBy: Check if collection contains none by predicate
- Intersect: Find intersection of collections
- Difference: Find difference between collections
- Union: Find union of collections
- Without: Remove elements from collection
- WithoutBy: Remove elements by predicate
- WithoutNth: Remove nth element
- ElementsMatch: Check if elements match
- ElementsMatchBy: Check if elements match by predicate

### Map
- Keys: Get keys from map
- UniqKeys: Get unique keys from map
- HasKey: Check if map has key
- Values: Get values from map
- UniqValues: Get unique values from map
- ValueOr: Get value or fallback
- PickBy: Pick entries by predicate
- PickByKeys: Pick entries by keys
- PickByValues: Pick entries by values
- OmitBy: Omit entries by predicate
- OmitByKeys: Omit entries by keys
- OmitByValues: Omit entries by values
- Entries: Get entries from map
- ToPairs: Convert map to pairs
- FromEntries: Create map from entries
- FromPairs: Create map from pairs
- Invert: Invert map keys and values
- Assign: Assign multiple maps
- ChunkEntries: Split map entries into chunks
- MapKeys: Apply function to map keys
- MapValues: Apply function to map values
- MapEntries: Apply function to map entries
- MapToSlice: Convert map to slice
- FilterMapToSlice: Filter and map to slice
- FilterKeys: Filter map keys
- FilterValues: Filter map values

### Math
- Range: Generate range of numbers
- RangeFrom: Generate range from start
- RangeWithSteps: Generate range with steps
- Clamp: Clamp value between min and max
- Sum: Sum numbers
- SumBy: Sum by predicate
- Product: Product of numbers
- ProductBy: Product by predicate
- Mean: Mean of numbers
- MeanBy: Mean by predicate
- Mode: Mode of numbers

### Retry
- NewDebounce: Create debounced function
- NewDebounceBy: Create debounced function by key
- Attempt: Attempt operation with retries
- AttemptWithDelay: Attempt with delay
- AttemptWhile: Attempt while condition
- AttemptWhileWithDelay: Attempt while with delay
- NewTransaction: Create transaction
- NewThrottle: Create throttled function
- NewThrottleWithCount: Create throttled function with count
- NewThrottleBy: Create throttled function by key
- NewThrottleByWithCount: Create throttled function by key with count

### Slice
- Filter: Filter collection
- Map: Apply function to collection
- UniqMap: Apply function and get unique results
- FilterMap: Filter and map collection
- FlatMap: Apply function and flatten
- Reduce: Reduce collection
- ReduceRight: Reduce from right
- ForEach: Apply function to each element
- ForEachWhile: Apply function while condition
- Times: Call function n times
- Uniq: Get unique elements
- UniqBy: Get unique by predicate
- GroupBy: Group elements by key
- GroupByMap: Group elements by key to map
- Chunk: Split slice into chunks
- PartitionBy: Partition elements by predicate
- Flatten: Flatten nested sequences
- Concat: Concat iterators
- Interleave: Interleave collections
- Fill: Fill collection
- Repeat: Repeat element
- RepeatBy: Repeat by predicate
- KeyBy: Key collection by field
- Associate: Create map from collection
- AssociateI: Create map from collection with index
- SliceToMap: Convert slice to map
- SliceToMapI: Convert slice to map with index
- FilterSliceToMap: Filter and convert slice to map
- FilterSliceToMapI: Filter and convert slice to map with index
- Keyify: Create set from collection
- Drop: Drop first n elements
- DropRight: Drop last n elements
- DropWhile: Drop while condition
- DropRightWhile: Drop right while condition
- DropByIndex: Drop elements by index
- Reject: Reject elements
- RejectMap: Reject and map elements
- FilterReject: Filter and reject elements
- Count: Count elements
- CountBy: Count by predicate
- CountValues: Count values
- CountValuesBy: Count values by predicate
- Subset: Get subset of collection
- Slice: Slice collection
- Replace: Replace elements
- ReplaceAll: Replace all elements
- Compact: Compact collection
- IsSorted: Check if collection is sorted
- IsSortedByKey: Check if sorted by key
- Splice: Splice collection
- Cut: Cut string at separator
- CutPrefix: Cut prefix from string
- CutSuffix: Cut suffix from string
- Trim: Trim string
- TrimLeft: Trim left
- TrimPrefix: Trim prefix
- TrimRight: Trim right
- TrimSuffix: Trim suffix

### String
- RandomString: Generate random string
- Substring: Get substring
- ChunkString: Split string into chunks
- RuneLength: Get rune length
- PascalCase: Convert to pascal case
- CamelCase: Convert to camel case
- KebabCase: Convert to kebab case
- SnakeCase: Convert to snake case
- Words: Split string into words
- Capitalize: Capitalize string
- Ellipsis: Truncate string with ellipsis

### Time
- Duration: Measure duration
- Duration0-Duration10: Measure duration with 0-10 return values
- EarliestBy: Find earliest by predicate
- Latest: Find latest time
- LatestBy: Find latest by predicate

### Tuple
- T2-T9: Create tuples with 2-9 elements
- Unpack2-Unpack9: Unpack tuples with 2-9 elements
- Zip2-Zip9: Zip 2-9 collections
- ZipBy2-ZipBy9: Zip 2-9 collections by predicate
- CrossJoin2-CrossJoin9: Cross join 2-9 collections
- CrossJoinBy2-CrossJoinBy9: Cross join 2-9 collections by predicate

### Type
- IsNil: Check if nil
- IsNotNil: Check if not nil
- ToPtr: Convert to pointer
- Nil: Get nil value
- EmptyableToPtr: Convert emptyable to pointer
- FromPtr: Convert from pointer
- FromPtrOr: Convert from pointer or fallback
- ToSlicePtr: Convert slice to pointer slice
- FromSlicePtr: Convert pointer slice to slice
- FromSlicePtrOr: Convert pointer slice or fallback
- ToAnySlice: Convert to any slice
- FromAnySlice: Convert from any slice
- Empty: Get empty value
- IsEmpty: Check if value is empty
- IsNotEmpty: Check if value is not empty
- Coalesce: Return first non-empty value
- CoalesceOrEmpty: Return first non-empty or empty
- CoalesceSlice: Return first non-empty slice
- CoalesceSliceOrEmpty: Return first non-empty slice or empty
- CoalesceMap: Return first non-empty map
- CoalesceMapOrEmpty: Return first non-empty map or empty

### Channel
- ChannelDispatcher: Channel dispatcher interface
- DispatchingStrategyRoundRobin: Round robin dispatching strategy
- DispatchingStrategyRandom: Random dispatching strategy
- DispatchingStrategyWeightedRandom: Weighted random dispatching strategy
- DispatchingStrategyFirst: First available dispatching strategy
- DispatchingStrategyLeast: Least busy dispatching strategy
- DispatchingStrategyMost: Most busy dispatching strategy
- SliceToChannel: Convert slice to channel
- ChannelToSlice: Convert channel to slice
- Buffer: Buffer channel values
- BufferWithContext: Buffer with context
- BufferWithTimeout: Buffer with timeout
- FanIn: Fan in multiple channels
- FanOut: Fan out to multiple channels

## Mutable Package Helpers

The lo/mutable package provides in-place mutation helpers for memory-efficient operations on slices:

- Filter: Filter collection in-place, removing elements that don't match predicate
- FilterI: Filter collection in-place with index predicate
- Map: Apply function to collection elements in-place
- MapI: Apply function to collection elements with index in-place
- Shuffle: Shuffle collection in-place using Fisher-Yates algorithm
- Reverse: Reverse collection in-place

## Parallel Package Helpers

The lo/parallel package provides parallel processing helpers for concurrent operations on slices:

- Map: Transform collection using parallel processing, maintaining order
- ForEach: Apply function to each element in parallel
- Times: Call function n times in parallel, returning slice of results
- GroupBy: Group collection by key using parallel processing
- PartitionBy: Partition collection by predicate using parallel processing

## Iterator Package Helpers

The lo/it package provides iterator helpers for lazy evaluation and streaming operations on sequences:

### Channel Operations
- SeqToChannel: Convert sequence to buffered channel
- SeqToChannel2: Convert key-value sequence to buffered channel
- ChannelToSeq: Convert channel to sequence

### Find Operations
- IndexOf: Find index of element in sequence
- LastIndexOf: Find last index of element in sequence
- Find: Find element by predicate
- FindIndexOf: Find element and index by predicate
- FindLastIndexOf: Find last element and index by predicate
- FindOrElse: Find element or return fallback
- FindUniques: Find unique elements in sequence
- FindUniquesBy: Find unique elements by transform
- FindDuplicates: Find duplicate elements in sequence
- FindDuplicatesBy: Find duplicates by transform
- Min: Find minimum value in sequence
- MinBy: Find minimum by comparison function
- MinIndex: Find minimum value and index
- MinIndexBy: Find minimum and index by comparison
- Max: Find maximum value in sequence
- MaxBy: Find maximum by comparison function
- MaxIndex: Find maximum value and index
- MaxIndexBy: Find maximum and index by comparison
- Earliest: Find earliest time in sequence
- EarliestBy: Find earliest by transform
- Latest: Find latest time in sequence
- LatestBy: Find latest by transform
- First: Get first element of sequence
- FirstOrEmpty: Get first element or zero value
- FirstOr: Get first element or fallback
- Last: Get last element of sequence
- LastOrEmpty: Get last element or zero value
- LastOr: Get last element or fallback
- Nth: Get nth element by index
- NthOr: Get nth element or fallback
- NthOrEmpty: Get nth element or zero value
- Sample: Get random element from sequence
- SampleBy: Get random element using custom generator
- Samples: Get N random unique elements
- SamplesBy: Get N random elements using custom generator

### Intersect Operations
- Contains: Check if sequence contains element
- ContainsBy: Check if sequence contains element by predicate
- Every: Check if sequence contains all subset elements
- EveryBy: Check if predicate returns true for all elements
- Some: Check if sequence contains any subset elements
- SomeBy: Check if predicate returns true for any element
- None: Check if sequence contains no subset elements
- NoneBy: Check if predicate returns true for no elements
- Intersect: Find intersection of multiple sequences
- Union: Find union of multiple sequences
- Without: Exclude elements from sequence
- WithoutBy: Exclude elements by key transform
- WithoutNth: Exclude elements by index
- ElementsMatch: Check if sequences contain same elements
- ElementsMatchBy: Check if sequences match by transform

### Map Operations
- Keys: Create sequence of map keys
- UniqKeys: Create sequence of unique map keys
- Values: Create sequence of map values
- UniqValues: Create sequence of unique map values
- Entries: Transform map to key-value sequence
- ToPairs: Alias for Entries
- FromEntries: Transform key-value sequence to map
- FromPairs: Alias for FromEntries
- Invert: Create inverted key-value sequence
- Assign: Merge multiple map sequences
- ChunkEntries: Split map into chunks
- MapToSeq: Transform map to sequence by function
- FilterMapToSeq: Filter and transform map to sequence
- FilterKeys: Filter map keys to sequence
- FilterValues: Filter map values to sequence
- SeqToSeq2: Convert sequence to indexed sequence
- Seq2KeyToSeq: Extract keys from key-value sequence
- Seq2ValueToSeq: Extract values from key-value sequence

### Math Operations
- Range: Generate range of numbers
- RangeFrom: Generate range from start
- RangeWithSteps: Generate range with custom steps
- Sum: Sum numbers in sequence
- SumBy: Sum by transform function
- Product: Calculate product of numbers
- ProductBy: Calculate product by transform
- Mean: Calculate mean of numbers
- MeanBy: Calculate mean by transform
- Mode: Find most frequent values

### Sequence Operations
- Length: Get length of sequence
- Drain: Consume entire sequence
- Filter: Filter sequence by predicate
- FilterI: Filter sequence with index predicate
- Map: Transform sequence elements
- MapI: Transform elements with index
- UniqMap: Transform with unique results
- UniqMapI: Transform with unique results and index
- FilterMap: Filter and transform sequence
- FilterMapI: Filter and transform with index
- FlatMap: Transform and flatten sequence
- FlatMapI: Transform and flatten with index
- Reduce: Reduce sequence to single value
- ReduceI: Reduce with index awareness
- ReduceLast: Reduce from right to left
- ReduceLastI: Reduce from right with index
- ForEach: Apply function to each element
- ForEachI: Apply function with index
- ForEachWhile: Apply while predicate returns true
- ForEachWhileI: Apply while predicate with index
- Times: Generate sequence by calling function
- Uniq: Get unique elements
- UniqBy: Get unique elements by transform
- GroupBy: Group elements by key
- GroupByMap: Group elements to map by transform
- Chunk: Split sequence into chunks
- PartitionBy: Partition by predicate
- Flatten: Flatten nested sequences
- Concat: Concat iterators
- Interleave: Interleave multiple sequences
- Shuffle: Shuffle sequence randomly
- Reverse: Reverse sequence order
- Fill: Fill sequence with value
- Repeat: Repeat value N times
- RepeatBy: Repeat by calling function
- KeyBy: Create map from sequence
- Associate: Create map from sequence with transform
- AssociateI: Create map with index-aware transform
- SeqToMap: Convert sequence to map
- SeqToMapI: Convert with index-aware transform
- FilterSeqToMap: Filter and convert to map
- FilterSeqToMapI: Filter and convert with index
- Keyify: Create set from sequence
- Drop: Drop first N elements
- DropLast: Drop last N elements
- DropWhile: Drop while predicate is true
- DropLastWhile: Drop from end while predicate is true
- DropByIndex: Drop elements by index
- Reject: Reject elements by predicate
- RejectI: Reject with index predicate
- RejectMap: Reject and transform
- RejectMapI: Reject and transform with index
- Count: Count occurrences of value
- CountBy: Count elements matching predicate
- CountValues: Count all value frequencies
- CountValuesBy: Count frequencies by transform
- Subset: Get subset by offset and length
- Slice: Get slice by start and end
- Replace: Replace N occurrences of value
- ReplaceAll: Replace all occurrences
- Compact: Remove zero values
- IsSorted: Check if sequence is sorted
- IsSortedBy: Check if sorted by key
- Splice: Insert elements at index
- CutPrefix: Remove prefix if present
- CutSuffix: Remove suffix if present
- Trim: Remove elements from both ends
- TrimFirst: Remove from start
- TrimPrefix: Remove prefix
- TrimLast: Remove from end
- TrimSuffix: Remove suffix

### String Operations
- ChunkString: Split string into chunks

### Tuple Operations
- Zip2-Zip9: Zip 2-9 sequences together
- ZipBy2-ZipBy9: Zip 2-9 sequences with custom transform
- CrossJoin2-CrossJoin9: Cross join 2-9 sequences
- CrossJoinBy2-CrossJoinBy9: Cross join 2-9 sequences with custom transform

### Type Manipulation
- ToSeqPtr: Convert sequence to pointer sequence
- FromSeqPtr: Convert pointer sequence back
- FromSeqPtrOr: Convert with fallback value
- ToAnySeq: Convert to any type sequence
- FromAnySeq: Convert from any type sequence
- Empty: Create empty sequence
- IsEmpty: Check if sequence is empty
- IsNotEmpty: Check if sequence is not empty
- CoalesceSeq: Return first non-empty sequence
- CoalesceSeqOrEmpty: Return first non-empty or empty

## Additional Resources

- **Documentation**: https://lo.samber.dev
- **GoDoc**: https://pkg.go.dev/github.com/samber/lo
- **GitHub**: https://github.com/samber/lo
- **Playground**: Every helper includes a Go Playground example for quick testing
- **Community**: Active community with contributions from hundreds of developers

## Usage Examples

### Basic Collection Operations

```go
import "github.com/samber/lo"

// Remove duplicates from a slice
names := lo.Uniq([]string{"Samuel", "John", "Samuel"})
// []string{"Samuel", "John"}

// Filter and transform in one operation
numbers := lo.FilterMap([]int{1, 2, 3, 4, 5}, func(item int, index int) (string, bool) {
    if item%2 == 0 {
        return fmt.Sprintf("even-%d", item), true
    }
    return "", false
})
// []string{"even-2", "even-4"}
```

### Advanced Data Processing

```go
// Complex data transformation pipeline
users := []User{{ID: 1, Name: "Alice", Active: true}, {ID: 2, Name: "Bob", Active: false}}

// Group active users by name length, then extract IDs
activeUserIDs := lo.Pipe(
    users,
    lo.Filter(func(u User) bool { return u.Active }),
    lo.GroupBy(func(u User) int { return len(u.Name) }),
    lo.MapValues(func(users []User) []int {
        return lo.Map(users, func(u User) int { return u.ID })
    }),
)
// map[int][]int{5: []int{1}}

// Safe nested data access
config := map[string]any{
    "database": map[string]any{
        "host": "localhost",
        "port": 5432,
    },
}

host := lo.ValueOr(lo.CoalesceMap(
    lo.MapValues(config, func(v any) map[string]any {
        if m, ok := v.(map[string]any); ok {
            return m
        }
        return nil
    }),
), "localhost")
```

### Concurrency and Async Operations

```go
// Parallel processing of large datasets
results := lop.Map(items, func(item Item) Result {
    return processItem(item) // Executed in parallel
})

// Debounce API calls to avoid rate limiting
debouncedSearch := lo.NewDebounce(300*time.Millisecond, func() {
    results := searchAPI(query)
    updateUI(results)
})

// Safe error handling with fallbacks
result, ok := lo.TryOr(func() (int, error) {
    return dangerousOperation()
}, 0)
```

### Functional Control Flow

```go
// Elegant conditional logic
message := lo.If(user != nil, "Welcome back!").
    ElseIfF(isGuest, func() string { return "Welcome guest!" }).
    Else("Please login")

// Retry logic with exponential backoff
result, err := lo.AttemptWithDelay(3, time.Second, func(i int, d time.Duration) error {
    return callExternalAPI(context.Background())
})

// Transaction management
tx := lo.NewTransaction[Order]()
defer tx.Rollback()

order, err := tx.Run(func() (Order, error) {
    inventory := checkInventory(items)
    if !inventory.Available {
        return Order{}, errors.New("insufficient inventory")
    }
    return createOrder(user, items)
})
```

## Performance Considerations

Lo is engineered for performance-critical applications with several optimization strategies:

### Memory Efficiency
- **Zero-copy patterns**: Many helpers avoid unnecessary allocations by working with existing data
- **Slice reuse**: Mutable variants (`lo/mutable`) enable in-place operations for memory-constrained environments
- **Lazy evaluation**: Iterator patterns in `lo/iter` support streaming of large datasets
- **Pre-allocation**: Collection sizes are pre-calculated when possible to minimize reallocations

### Performance Characteristics
- **Compile-time optimization**: Generic types enable compile-time specialization and optimization
- **Minimal overhead**: Most helpers add zero or single-digit nanosecond overhead
- **Cache-friendly**: Linear memory access patterns for better CPU cache utilization
- **Branch prediction**: Hot paths are optimized for common case execution

### Benchmarks and Optimization
Every helper includes comprehensive benchmarks covering:
- Different input sizes (small, medium, large)
- Various data types (int, string, structs)
- Comparison with standard library alternatives
- Memory allocation tracking

```go
// Example benchmark results for lo.Uniq vs manual implementation
BenchmarkLoUniq-8          1000000    1200 ns/op    800 B/op   4 allocs/op
BenchmarkManualUniq-8       5000000     240 ns/op     0 B/op   0 allocs/op  (when in-place)
```

### Production Optimization Tips
1. **Use `lo/it`** for large datasets when memory is a concern
2. **Leverage `lo/parallel`** for CPU-bound operations on large collections
3. **Choose appropriate helpers** - some have specialized variants for specific use cases
4. **Profile your code** - use Go's built-in profiling tools to identify bottlenecks
5. **Consider streaming** - use iterators for very large datasets that don't fit in memory

## Ecosystem and Community

### Related Projects
Lo is part of a growing ecosystem of Go libraries that enhance developer productivity:

- **[samber/ro](https://github.com/samber/ro)**: Reactive Programming library for Go
- **[samber/do](https://github.com/samber/do)**: A dependency injection toolkit based on Go 1.18+ Generics
- **[samber/mo](https://github.com/samber/mo)**: Monads based on Go 1.18+ Generics (Option, Result, Either...)

### Community and Contributions
- **Active development**: Regular updates and improvements from maintainers
- **Community contributions**: Hundreds of contributors from around the world
- **Corporate adoption**: Used by major companies including startups, fintech, and enterprise organizations
- **Discussions**: Active GitHub discussions for feature requests and support

## Migration and Adoption

### From Standard Library
Migrating from standard library `slices` and `maps` packages is straightforward:
- Lo provides similar APIs with additional features
- Many helpers drop-in replace standard library functions
- Enhanced error handling and edge case coverage

### From Other Libraries
If you're coming from other utility libraries:
- Lo emphasizes Go idioms over direct ports from other languages
- Type safety is prioritized over dynamic patterns
- Performance is a key consideration in all implementations

## License

MIT License - see LICENSE file for details

## Acknowledgments

Lo stands on the shoulders of giants:
- Inspired by Lodash, Underscore.js, and functional programming concepts
- Built upon Go's excellent generics implementation
- Community-driven with contributions from hundreds of developers
- Production-tested across diverse use cases and industries
