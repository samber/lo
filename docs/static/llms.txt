# Lo - A Go library for functional programming

Lo is a comprehensive, production-ready Lodash-style Go library built on Go 1.18+ generics that provides hundreds of utility functions for working with slices, maps, strings, channels, functions, and more. It aims to make Go code more expressive, readable, and productive by offering a rich collection of functional programming helpers inspired by libraries like Lodash in JavaScript.

## Origins and Purpose

Born from the need to fill gaps in Go's standard library after the introduction of generics in Go 1.18, Lo addresses common pain points that Go developers face daily. While Go's standard library gained some generic helpers in `slices` and `maps` packages, Lo goes far beyond with 300+ carefully crafted utilities that make functional programming patterns natural and idiomatic in Go.

The library emerged from real-world production needs and has been battle-tested in numerous high-traffic applications, microservices, and enterprise systems. It's not just a collection of utility functions, but a thoughtful toolkit that enables developers to write more declarative, maintainable, and bug-free code.

## Key Features

- **Generic-based**: Fully leverages Go 1.18+ generics for compile-time type safety
- **Zero dependencies**: No external dependencies outside the Go standard library
- **Comprehensive**: 300+ helpers covering slices, maps, strings, channels, functions, and more
- **Functional programming**: Brings functional programming paradigms to Go naturally
- **Production-ready**: Battle-tested in high-traffic applications worldwide
- **Well-tested**: 95%+ test coverage with comprehensive examples
- **SemVer compliant**: Follows strict semantic versioning (v1.x.x stable)
- **Performance-focused**: Minimal runtime overhead with optimized implementations
- **Memory efficient**: Many helpers avoid allocations and use zero-copy patterns
- **Composable**: Designed to work together in method chains and complex pipelines

## Sub-packages

The main package is complemented by several specialized sub-packages:

- **lo**: Core package with 300+ helpers for everyday operations
- **lo/parallel**: Parallel processing helpers for concurrent operations
- **lo/mutable**: In-place mutation helpers for memory-efficient operations
- **lo/it**: Iterator helpers for lazy evaluation and streaming

## Design Philosophy

Lo is built on a foundation of pragmatic engineering principles that balance power, safety, and performance:

1. **Type Safety First**: All helpers leverage Go's generics for compile-time type checking, eliminating runtime type assertions and reducing bugs
2. **Go Idiomatic**: While inspired by functional programming, helpers feel natural in Go code and follow established conventions
3. **Performance Conscious**: Every helper is benchmarked and optimized for minimal overhead, with many using zero-copy patterns
4. **Explicit Clarity**: Helper names clearly communicate their purpose and behavior
5. **Composable by Design**: Functions work together seamlessly, enabling elegant data transformation pipelines
6. **Memory Efficient**: Careful attention to allocation patterns, with many helpers avoiding unnecessary heap allocations
7. **Error Handling Respect**: Helpers don't hide errors; they integrate naturally with Go's error handling patterns
8. **Practical Over Pure**: Prioritizes solving real-world problems over theoretical purity

## Core Package Helpers

### Condition
- Ternary: Return value based on condition
- TernaryF: Return value from function based on condition
- If: Return value if condition is true
- IfF: Return value from function if condition is true
- ElseIf: Return value if previous condition was false and this condition is true
- ElseIfF: Return value from function if previous condition was false and this condition is true
- Else: Return value if all previous conditions were false
- ElseF: Return value from function if all previous conditions were false
- Switch: Return value based on first matching case
- Case: Define a case for switch statement
- CaseF: Define a case with function execution for switch statement
- Default: Define default case for switch statement
- DefaultF: Define default case with function execution for switch statement

### Concurrency
- Synchronize: Coordinate multiple goroutines with mutex
- Async: Execute function in goroutine and return channel
- Async0-Async6: Execute functions with 0-6 return values in goroutines
- WaitFor: Block until condition becomes true
- WaitForWithContext: Block until condition becomes true with context cancellation

### Error Handling
- Validate: Return error if condition is false
- Must: Panic if error is not nil, otherwise return value
- Must0-Must6: Panic if error is not nil, otherwise return 0-6 values
- Try: Execute function and panic on error
- Try0-Try6: Execute function with 0-6 return values and panic on error
- TryOr: Execute function and return fallback value on error
- TryOr1-TryOr6: Execute function with 1-6 return values and return fallback on error
- TryWithErrorValue: Execute function and return error value on panic
- TryCatch: Execute function with panic recovery
- TryCatchWithErrorValue: Execute function with panic recovery and error value
- ErrorsAs: Convert error to target type
- Assert: Panic if condition is false
- Assertf: Panic with formatted message if condition is false

### Find
- IndexOf: Get index of first matching element
- LastIndexOf: Get index of last matching element
- HasPrefix: Check if collection starts with elements
- HasSuffix: Check if collection ends with elements
- Find: Get first element matching predicate
- FindIndexOf: Get first element and its index matching predicate
- FindLastIndexOf: Get last element and its index matching predicate
- FindOrElse: Get first element matching predicate or fallback value
- FindKey: Get first key in map with matching value
- FindKeyBy: Get first key in map matching predicate
- FindUniques: Get slice of unique elements
- FindUniquesBy: Get slice of unique elements by transform
- FindDuplicates: Get slice of duplicate elements
- FindDuplicatesBy: Get slice of duplicate elements by transform
- Min: Get minimum value in collection
- MinIndex: Get index of minimum value
- MinBy: Get minimum value by comparison function
- MinIndexBy: Get index of minimum value by comparison function
- Earliest: Get earliest time value
- EarliestBy: Get earliest value by time comparison
- Max: Get maximum value in collection
- MaxIndex: Get index of maximum value
- MaxBy: Get maximum value by comparison function
- MaxIndexBy: Get index of maximum value by comparison function
- Latest: Get latest time value
- LatestBy: Get latest value by time comparison
- First: Get first element from collection
- FirstOrEmpty: Get first element or zero value
- FirstOr: Get first element or fallback value
- Last: Get last element from collection
- LastOrEmpty: Get last element or zero value
- LastOr: Get last element or fallback value
- Nth: Get element at index
- NthOr: Get element at index or fallback value
- NthOrEmpty: Get element at index or zero value
- Sample: Get random element from collection
- SampleBy: Get random element using custom generator
- Samples: Get N random unique elements
- SamplesBy: Get N random elements using custom generator

### Function
- Partial: Create function with some arguments pre-filled
- Partial1-Partial5: Create functions with 1-5 arguments pre-filled

### Intersect
- Contains: Check if collection contains element
- ContainsBy: Check if collection contains element matching predicate
- Every: Check if all elements in collection match subset
- EveryBy: Check if all elements match predicate
- Some: Check if any elements in collection match subset
- SomeBy: Check if any elements match predicate
- None: Check if no elements in collection match subset
- NoneBy: Check if no elements match predicate
- Intersect: Get elements common to all collections
- Difference: Get elements in first collection but not in others
- Union: Get all unique elements from collections
- Without: Get collection with specified elements removed
- WithoutBy: Get collection with elements removed by predicate
- WithoutNth: Get collection with element at index removed
- ElementsMatch: Check if collections contain same elements
- ElementsMatchBy: Check if collections match by transform function

### Map
- Keys: Get slice of map keys
- UniqKeys: Get slice of unique map keys
- HasKey: Check if map contains key
- Values: Get slice of map values
- UniqValues: Get slice of unique map values
- ValueOr: Get map value or fallback if key not found
- PickBy: Create map with entries matching predicate
- PickByKeys: Create map with specified keys
- PickByValues: Create map with specified values
- OmitBy: Create map without entries matching predicate
- OmitByKeys: Create map without specified keys
- OmitByValues: Create map without specified values
- Entries: Get slice of key-value pairs from map
- ToPairs: Alias for Entries
- FromEntries: Create map from key-value pairs
- FromPairs: Alias for FromEntries
- Invert: Create map with keys and values swapped
- Assign: Merge multiple maps into one
- ChunkEntries: Split map entries into chunks of specified size
- MapKeys: Transform map keys using function
- MapValues: Transform map values using function
- MapEntries: Transform map entries using function
- MapToSlice: Convert map to slice using function
- FilterMapToSlice: Filter and convert map to slice
- FilterKeys: Get slice of keys matching predicate
- FilterValues: Get slice of values matching predicate

### Math
- Range: Generate slice of numbers from 0 to n-1
- RangeFrom: Generate slice of numbers from start to end
- RangeWithSteps: Generate slice of numbers with custom step size
- Clamp: Constrain value between minimum and maximum
- Sum: Calculate sum of numbers
- SumBy: Calculate sum by applying function to each element
- Product: Calculate product of numbers
- ProductBy: Calculate product by applying function to each element
- Mean: Calculate arithmetic mean of numbers
- MeanBy: Calculate mean by applying function to each element
- Mode: Find most frequently occurring value

### Retry
- NewDebounce: Create function that delays execution until after calls stop
- NewDebounceBy: Create debounced function with key-based grouping
- Attempt: Execute function with specified number of retries
- AttemptWithDelay: Execute function with retries and delay between attempts
- AttemptWhile: Execute function while condition is true
- AttemptWhileWithDelay: Execute function while condition is true with delay
- NewTransaction: Create transaction with rollback capability
- NewThrottle: Create function that limits execution frequency
- NewThrottleWithCount: Create throttled function with execution count limit
- NewThrottleBy: Create throttled function with key-based grouping
- NewThrottleByWithCount: Create throttled function with key-based grouping and count limit

### Slice
- Filter: Get elements matching predicate
- Map: Transform each element using function
- UniqMap: Transform elements and remove duplicates
- FilterMap: Filter and transform elements in one operation
- FlatMap: Transform elements and flatten result
- Reduce: Combine elements into single value
- ReduceRight: Combine elements from right to left
- ForEach: Execute function for each element
- ForEachWhile: Execute function while predicate returns true
- Times: Execute function n times and collect results
- Uniq: Remove duplicate elements
- UniqBy: Remove duplicates by key function
- GroupBy: Group elements by key function
- GroupByMap: Group elements by key function into map
- Chunk: Split slice into chunks of specified size
- PartitionBy: Split elements into two groups by predicate
- Flatten: Flatten nested slices into single slice
- Concat: Combine multiple slices into one
- Interleave: Interleave elements from multiple slices
- Fill: Fill slice with specified value
- Repeat: Create slice with element repeated n times
- RepeatBy: Create slice by calling function n times
- KeyBy: Create map from slice using key function
- Associate: Create map from slice using key-value function
- AssociateI: Create map from slice with index-aware function
- SliceToMap: Convert slice to map using key function
- SliceToMapI: Convert slice to map with index-aware function
- FilterSliceToMap: Filter and convert slice to map
- FilterSliceToMapI: Filter and convert slice to map with index
- Keyify: Create set from slice elements
- Drop: Remove first n elements
- DropRight: Remove last n elements
- DropWhile: Remove elements from start while predicate is true
- DropRightWhile: Remove elements from end while predicate is true
- DropByIndex: Remove elements at specified indices
- Reject: Remove elements matching predicate
- RejectMap: Remove and transform elements matching predicate
- FilterReject: Split elements into matching and non-matching groups
- Count: Count occurrences of value
- CountBy: Count elements matching predicate
- CountValues: Count frequency of each value
- CountValuesBy: Count frequency by key function
- Subset: Get slice of elements from offset with length
- Slice: Get slice of elements from start to end
- Replace: Replace first n occurrences of value
- ReplaceAll: Replace all occurrences of value
- Compact: Remove zero values from slice
- IsSorted: Check if slice is sorted in ascending order
- IsSortedByKey: Check if slice is sorted by key function
- Splice: Insert elements at specified index
- Cut: Split string at first occurrence of separator
- CutPrefix: Remove prefix from string if present
- CutSuffix: Remove suffix from string if present
- Trim: Remove whitespace from both ends of string
- TrimLeft: Remove whitespace from start of string
- TrimPrefix: Remove prefix from string if present
- TrimRight: Remove whitespace from end of string
- TrimSuffix: Remove suffix from string if present

### String
- RandomString: Generate random string of specified length
- Substring: Extract substring from start to end
- ChunkString: Split string into chunks of specified size
- RuneLength: Get number of runes in string
- PascalCase: Convert string to PascalCase
- CamelCase: Convert string to camelCase
- KebabCase: Convert string to kebab-case
- SnakeCase: Convert string to snake_case
- Words: Split string into slice of words
- Capitalize: Capitalize first letter of string
- Ellipsis: Truncate string to length with ellipsis

### Time
- Duration: Measure execution time of function
- Duration0-Duration10: Measure execution time of function with 0-10 return values
- EarliestBy: Find earliest time value by comparison function
- Latest: Find latest time value
- LatestBy: Find latest time value by comparison function

### Tuple
- T2-T9: Create tuple with 2-9 elements
- Unpack2-Unpack9: Unpack tuple with 2-9 elements into variables
- Zip2-Zip9: Combine 2-9 collections into tuples
- ZipBy2-ZipBy9: Combine 2-9 collections into tuples using function
- CrossJoin2-CrossJoin9: Create cartesian product of 2-9 collections
- CrossJoinBy2-CrossJoinBy9: Create cartesian product of 2-9 collections using function

### Type
- IsNil: Check if value is nil
- IsNotNil: Check if value is not nil
- ToPtr: Convert value to pointer
- Nil: Get nil value of type
- EmptyableToPtr: Convert emptyable value to pointer
- FromPtr: Get value from pointer
- FromPtrOr: Get value from pointer or fallback if nil
- ToSlicePtr: Convert slice to slice of pointers
- FromSlicePtr: Convert slice of pointers to slice
- FromSlicePtrOr: Convert slice of pointers to slice or fallback
- ToAnySlice: Convert slice to []any
- FromAnySlice: Convert []any to typed slice
- Empty: Get zero value of type
- IsEmpty: Check if value is zero/empty
- IsNotEmpty: Check if value is not zero/empty
- Coalesce: Return first non-zero value
- CoalesceOrEmpty: Return first non-zero value or zero value
- CoalesceSlice: Return first non-empty slice
- CoalesceSliceOrEmpty: Return first non-empty slice or empty slice
- CoalesceMap: Return first non-empty map
- CoalesceMapOrEmpty: Return first non-empty map or empty map

### Channel
- ChannelDispatcher: Interface for dispatching values to channels
- DispatchingStrategyRoundRobin: Distribute values evenly across channels
- DispatchingStrategyRandom: Distribute values randomly across channels
- DispatchingStrategyWeightedRandom: Distribute values with weighted randomness
- DispatchingStrategyFirst: Send to first available channel
- DispatchingStrategyLeast: Send to least busy channel
- DispatchingStrategyMost: Send to most busy channel
- SliceToChannel: Convert slice to buffered channel
- ChannelToSlice: Collect all values from channel into slice
- Buffer: Buffer channel values with specified capacity
- BufferWithContext: Buffer channel values with context cancellation
- BufferWithTimeout: Buffer channel values with timeout
- FanIn: Combine multiple channels into single channel
- FanOut: Distribute single channel to multiple channels

## Mutable Package Helpers

The lo/mutable package provides in-place mutation helpers for memory-efficient operations on slices:

- Filter: Remove elements that don't match predicate in-place
- FilterI: Remove elements that don't match index predicate in-place
- Map: Transform collection elements in-place
- MapI: Transform collection elements with index in-place
- Shuffle: Randomly shuffle collection in-place using Fisher-Yates algorithm
- Reverse: Reverse order of collection elements in-place

## Parallel Package Helpers

The lo/parallel package provides parallel processing helpers for concurrent operations on slices:

- Map: Transform collection elements in parallel while maintaining order
- ForEach: Execute function on each element in parallel
- Times: Execute function n times in parallel and collect results
- GroupBy: Group collection elements by key using parallel processing
- PartitionBy: Split collection into two groups by predicate using parallel processing

## Iterator Package Helpers

The lo/it package provides iterator helpers for lazy evaluation and streaming operations on sequences:

### Channel Operations
- SeqToChannel: Convert sequence to buffered channel
- SeqToChannel2: Convert key-value sequence to buffered channel
- ChannelToSeq: Convert channel to sequence

### Find Operations
- IndexOf: Get index of first matching element in sequence
- LastIndexOf: Get index of last matching element in sequence
- Find: Get first element matching predicate
- FindIndexOf: Get first element and its index matching predicate
- FindLastIndexOf: Get last element and its index matching predicate
- FindOrElse: Get first element matching predicate or fallback value
- FindUniques: Get slice of unique elements from sequence
- FindUniquesBy: Get slice of unique elements by transform function
- FindDuplicates: Get slice of duplicate elements from sequence
- FindDuplicatesBy: Get slice of duplicate elements by transform function
- Min: Get minimum value from sequence
- MinBy: Get minimum value by comparison function
- MinIndex: Get minimum value and its index
- MinIndexBy: Get minimum value and index by comparison function
- Max: Get maximum value from sequence
- MaxBy: Get maximum value by comparison function
- MaxIndex: Get maximum value and its index
- MaxIndexBy: Get maximum value and index by comparison function
- Earliest: Get earliest time value from sequence
- EarliestBy: Get earliest value by time comparison function
- Latest: Get latest time value from sequence
- LatestBy: Get latest value by time comparison function
- First: Get first element from sequence
- FirstOrEmpty: Get first element or zero value
- FirstOr: Get first element or fallback value
- Last: Get last element from sequence
- LastOrEmpty: Get last element or zero value
- LastOr: Get last element or fallback value
- Nth: Get element at index from sequence
- NthOr: Get element at index or fallback value
- NthOrEmpty: Get element at index or zero value
- Sample: Get random element from sequence
- SampleBy: Get random element using custom generator
- Samples: Get N random unique elements from sequence
- SamplesBy: Get N random elements using custom generator

### Intersect Operations
- Contains: Check if sequence contains element
- ContainsBy: Check if sequence contains element matching predicate
- Every: Check if all elements in sequence match subset
- EveryBy: Check if all elements match predicate
- Some: Check if any elements in sequence match subset
- SomeBy: Check if any elements match predicate
- None: Check if no elements in sequence match subset
- NoneBy: Check if no elements match predicate
- Intersect: Get elements common to all sequences
- Union: Get all unique elements from sequences
- Without: Get sequence with specified elements excluded
- WithoutBy: Get sequence with elements excluded by key transform
- WithoutNth: Get sequence with element at index excluded
- ElementsMatch: Check if sequences contain same elements
- ElementsMatchBy: Check if sequences match by transform function

### Map Operations
- Keys: Create sequence from map keys
- UniqKeys: Create sequence from unique map keys
- Values: Create sequence from map values
- UniqValues: Create sequence from unique map values
- Entries: Transform map to key-value sequence
- ToPairs: Alias for Entries
- FromEntries: Transform key-value sequence to map
- FromPairs: Alias for FromEntries
- Invert: Create sequence with keys and values swapped
- Assign: Merge multiple map sequences into one
- ChunkEntries: Split map entries into chunks of specified size
- MapToSeq: Transform map to sequence using function
- FilterMapToSeq: Filter and transform map to sequence
- FilterKeys: Get sequence of keys matching predicate
- FilterValues: Get sequence of values matching predicate
- SeqToSeq2: Convert sequence to indexed sequence
- Seq2KeyToSeq: Extract keys from key-value sequence
- Seq2ValueToSeq: Extract values from key-value sequence

### Math Operations
- Range: Generate sequence of numbers from 0 to n-1
- RangeFrom: Generate sequence of numbers from start to end
- RangeWithSteps: Generate sequence of numbers with custom step size
- Sum: Calculate sum of numbers in sequence
- SumBy: Calculate sum by applying function to each element
- Product: Calculate product of numbers in sequence
- ProductBy: Calculate product by applying function to each element
- Mean: Calculate arithmetic mean of numbers in sequence
- MeanBy: Calculate mean by applying function to each element
- Mode: Find most frequently occurring values in sequence

### Sequence Operations
- Length: Get number of elements in sequence
- Drain: Consume entire sequence and return slice
- Filter: Get elements matching predicate
- FilterI: Get elements matching index predicate
- Map: Transform each element using function
- MapI: Transform elements with index using function
- UniqMap: Transform elements and remove duplicates
- UniqMapI: Transform elements with index and remove duplicates
- FilterMap: Filter and transform elements in one operation
- FilterMapI: Filter and transform elements with index in one operation
- FlatMap: Transform elements and flatten result
- FlatMapI: Transform elements with index and flatten result
- Reduce: Combine elements into single value
- ReduceI: Combine elements with index awareness
- ReduceLast: Combine elements from right to left
- ReduceLastI: Combine elements from right with index
- ForEach: Execute function for each element
- ForEachI: Execute function with index for each element
- ForEachWhile: Execute function while predicate returns true
- ForEachWhileI: Execute function with index while predicate returns true
- Times: Execute function n times and collect results
- Uniq: Remove duplicate elements
- UniqBy: Remove duplicates by key function
- GroupBy: Group elements by key function
- GroupByMap: Group elements by key function into map
- Chunk: Split sequence into chunks of specified size
- PartitionBy: Split elements into two groups by predicate
- Flatten: Flatten nested sequences into single sequence
- Concat: Combine multiple sequences into one
- Interleave: Interleave elements from multiple sequences
- Shuffle: Randomly shuffle sequence elements
- Reverse: Reverse order of sequence elements
- Fill: Fill sequence with specified value
- Repeat: Create sequence with value repeated n times
- RepeatBy: Create sequence by calling function n times
- KeyBy: Create map from sequence using key function
- Associate: Create map from sequence using key-value function
- AssociateI: Create map from sequence with index-aware function
- SeqToMap: Convert sequence to map using key function
- SeqToMapI: Convert sequence to map with index-aware function
- FilterSeqToMap: Filter and convert sequence to map
- FilterSeqToMapI: Filter and convert sequence to map with index
- Keyify: Create set from sequence elements
- Drop: Remove first n elements
- DropLast: Remove last n elements
- DropWhile: Remove elements from start while predicate is true
- DropLastWhile: Remove elements from end while predicate is true
- DropByIndex: Remove elements at specified indices
- Reject: Remove elements matching predicate
- RejectI: Remove elements matching index predicate
- RejectMap: Remove and transform elements matching predicate
- RejectMapI: Remove and transform elements matching index predicate
- Count: Count occurrences of value in sequence
- CountBy: Count elements matching predicate
- CountValues: Count frequency of each value in sequence
- CountValuesBy: Count frequency by key function
- Subset: Get slice of elements from offset with length
- Slice: Get slice of elements from start to end
- Replace: Replace first n occurrences of value
- ReplaceAll: Replace all occurrences of value
- Compact: Remove zero values from sequence
- IsSorted: Check if sequence is sorted in ascending order
- IsSortedBy: Check if sequence is sorted by key function
- Splice: Insert elements at specified index
- CutPrefix: Remove prefix from sequence if present
- CutSuffix: Remove suffix from sequence if present
- Trim: Remove elements from both ends of sequence
- TrimFirst: Remove elements from start of sequence
- TrimPrefix: Remove prefix from sequence if present
- TrimLast: Remove elements from end of sequence
- TrimSuffix: Remove suffix from sequence if present

### String Operations
- ChunkString: Split string into chunks of specified size

### Tuple Operations
- Zip2-Zip9: Combine 2-9 sequences into tuples
- ZipBy2-ZipBy9: Combine 2-9 sequences into tuples using function
- CrossJoin2-CrossJoin9: Create cartesian product of 2-9 sequences
- CrossJoinBy2-CrossJoinBy9: Create cartesian product of 2-9 sequences using function

### Type Manipulation
- ToSeqPtr: Convert sequence to sequence of pointers
- FromSeqPtr: Convert sequence of pointers to sequence
- FromSeqPtrOr: Convert sequence of pointers to sequence or fallback
- ToAnySeq: Convert sequence to []any
- FromAnySeq: Convert []any to typed sequence
- Empty: Create empty sequence
- IsEmpty: Check if sequence is empty
- IsNotEmpty: Check if sequence is not empty
- CoalesceSeq: Return first non-empty sequence
- CoalesceSeqOrEmpty: Return first non-empty sequence or empty sequence

## Additional Resources

- **Documentation**: https://lo.samber.dev
- **GoDoc**: https://pkg.go.dev/github.com/samber/lo
- **GitHub**: https://github.com/samber/lo
- **Playground**: Every helper includes a Go Playground example for quick testing
- **Community**: Active community with contributions from hundreds of developers

## Usage Examples

### Basic Collection Operations

```go
import "github.com/samber/lo"

// Remove duplicates from a slice
names := lo.Uniq([]string{"Samuel", "John", "Samuel"})
// []string{"Samuel", "John"}

// Filter and transform in one operation
numbers := lo.FilterMap([]int{1, 2, 3, 4, 5}, func(item int, index int) (string, bool) {
    if item%2 == 0 {
        return fmt.Sprintf("even-%d", item), true
    }
    return "", false
})
// []string{"even-2", "even-4"}
```

### Advanced Data Processing

```go
// Complex data transformation pipeline
users := []User{{ID: 1, Name: "Alice", Active: true}, {ID: 2, Name: "Bob", Active: false}}

// Group active users by name length, then extract IDs
activeUserIDs := lo.Pipe(
    users,
    lo.Filter(func(u User) bool { return u.Active }),
    lo.GroupBy(func(u User) int { return len(u.Name) }),
    lo.MapValues(func(users []User) []int {
        return lo.Map(users, func(u User) int { return u.ID })
    }),
)
// map[int][]int{5: []int{1}}

// Safe nested data access
config := map[string]any{
    "database": map[string]any{
        "host": "localhost",
        "port": 5432,
    },
}

host := lo.ValueOr(lo.CoalesceMap(
    lo.MapValues(config, func(v any) map[string]any {
        if m, ok := v.(map[string]any); ok {
            return m
        }
        return nil
    }),
), "localhost")
```

### Concurrency and Async Operations

```go
// Parallel processing of large datasets
results := lop.Map(items, func(item Item) Result {
    return processItem(item) // Executed in parallel
})

// Debounce API calls to avoid rate limiting
debouncedSearch := lo.NewDebounce(300*time.Millisecond, func() {
    results := searchAPI(query)
    updateUI(results)
})

// Safe error handling with fallbacks
result, ok := lo.TryOr(func() (int, error) {
    return dangerousOperation()
}, 0)
```

### Functional Control Flow

```go
// Elegant conditional logic
message := lo.If(user != nil, "Welcome back!").
    ElseIfF(isGuest, func() string { return "Welcome guest!" }).
    Else("Please login")

// Retry logic with exponential backoff
result, err := lo.AttemptWithDelay(3, time.Second, func(i int, d time.Duration) error {
    return callExternalAPI(context.Background())
})

// Transaction management
tx := lo.NewTransaction[Order]()
defer tx.Rollback()

order, err := tx.Run(func() (Order, error) {
    inventory := checkInventory(items)
    if !inventory.Available {
        return Order{}, errors.New("insufficient inventory")
    }
    return createOrder(user, items)
})
```

## Performance Considerations

Lo is engineered for performance-critical applications with several optimization strategies:

### Memory Efficiency
- **Zero-copy patterns**: Many helpers avoid unnecessary allocations by working with existing data
- **Slice reuse**: Mutable variants (`lo/mutable`) enable in-place operations for memory-constrained environments
- **Lazy evaluation**: Iterator patterns in `lo/iter` support streaming of large datasets
- **Pre-allocation**: Collection sizes are pre-calculated when possible to minimize reallocations

### Performance Characteristics
- **Compile-time optimization**: Generic types enable compile-time specialization and optimization
- **Minimal overhead**: Most helpers add zero or single-digit nanosecond overhead
- **Cache-friendly**: Linear memory access patterns for better CPU cache utilization
- **Branch prediction**: Hot paths are optimized for common case execution

### Benchmarks and Optimization
Every helper includes comprehensive benchmarks covering:
- Different input sizes (small, medium, large)
- Various data types (int, string, structs)
- Comparison with standard library alternatives
- Memory allocation tracking

```go
// Example benchmark results for lo.Uniq vs manual implementation
BenchmarkLoUniq-8          1000000    1200 ns/op    800 B/op   4 allocs/op
BenchmarkManualUniq-8       5000000     240 ns/op     0 B/op   0 allocs/op  (when in-place)
```

### Production Optimization Tips
1. **Use `lo/it`** for large datasets when memory is a concern
2. **Leverage `lo/parallel`** for CPU-bound operations on large collections
3. **Choose appropriate helpers** - some have specialized variants for specific use cases
4. **Profile your code** - use Go's built-in profiling tools to identify bottlenecks
5. **Consider streaming** - use iterators for very large datasets that don't fit in memory

## Ecosystem and Community

### Related Projects
Lo is part of a growing ecosystem of Go libraries that enhance developer productivity:

- **[samber/ro](https://github.com/samber/ro)**: Reactive Programming library for Go
- **[samber/do](https://github.com/samber/do)**: A dependency injection toolkit based on Go 1.18+ Generics
- **[samber/mo](https://github.com/samber/mo)**: Monads based on Go 1.18+ Generics (Option, Result, Either...)

### Community and Contributions
- **Active development**: Regular updates and improvements from maintainers
- **Community contributions**: Hundreds of contributors from around the world
- **Corporate adoption**: Used by major companies including startups, fintech, and enterprise organizations
- **Discussions**: Active GitHub discussions for feature requests and support

## Migration and Adoption

### From Standard Library
Migrating from standard library `slices` and `maps` packages is straightforward:
- Lo provides similar APIs with additional features
- Many helpers drop-in replace standard library functions
- Enhanced error handling and edge case coverage

### From Other Libraries
If you're coming from other utility libraries:
- Lo emphasizes Go idioms over direct ports from other languages
- Type safety is prioritized over dynamic patterns
- Performance is a key consideration in all implementations

## License

MIT License - see LICENSE file for details

## Acknowledgments

Lo stands on the shoulders of giants:
- Inspired by Lodash, Underscore.js, and functional programming concepts
- Built upon Go's excellent generics implementation
- Community-driven with contributions from hundreds of developers
- Production-tested across diverse use cases and industries
